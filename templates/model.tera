use sqlx::{MySql, QueryBuilder};

#[rustfmt::skip]
#[derive(sqlx::FromRow)]
pub struct {{ table.name | as_upper_camel_case}} {
{%- for column in table.columns %}
    pub {{column.name}}: {{column.data_type | to_rust_type(is_nullable=column.is_nullable) }},
{%- endfor %}
}

#[rustfmt::skip]
impl {{ table.name | as_upper_camel_case }} {
    pub fn new(
{%- if table.primary_key_columns | length > 1 %}
    {%- for column in table.primary_key_columns %}
        {{column.name}}: {{column.data_type | to_rust_type(is_nullable=column.is_nullable) }},
    {%- endfor %}
{%- endif %}
{%- for column in table.ordinary_columns %}
    {%- if column.name != "created_at" %}
        {{column.name}}: {{column.data_type | to_rust_type(is_nullable=column.is_nullable) }},
    {%- endif %}
{%- endfor %}
    ) -> {{ table.name | as_upper_camel_case }} {
        {{ table.name | as_upper_camel_case }} {
{%- if table.primary_key_columns | length > 1 %}
    {%- for column in table.primary_key_columns %} 
            {{column.name}},
    {%- endfor %}
{%- else %}
    {%- for column in table.primary_key_columns %} 
            {{column.name}}: {{column.data_type | to_rust_initialize(is_nullable=column.is_nullable) }},
    {%- endfor %}
{%- endif %}
{%- for column in table.ordinary_columns %} 
    {%- if column.name == "created_at" %}
            {{column.name}}: {{column.data_type | to_rust_initialize(is_nullable=column.is_nullable) }},
    {%- else %}
            {{column.name}},
    {%- endif %}
{%- endfor %}
        }
    }
}

#[rustfmt::skip]
#[derive(Debug, Default)]
pub struct {{ table.name | as_upper_camel_case}}Filter {
{%- for column in table.columns %}
    pub {{column.name}}: {{column.data_type | to_rust_type(is_nullable=true) }},
{%- endfor %}  
    pub page: Option<u64>,
    pub limit: Option<u64>,
}

const DEFAULT_LIMIT: u64 = 10;

#[rustfmt::skip]
impl {{ table.name | as_upper_camel_case}}Filter {

{%- for column in table.columns %}
    pub fn {{column.name}}(mut self, {{column.name}}: {{column.data_type | to_rust_type(is_nullable=false) }}) -> Self {
        self.{{column.name}} = Some({{column.name}});
        self
    }
{%- endfor %}  
    pub fn page(mut self, page: u64) -> Self {
        self.page = Some(page);
        self
    }
    pub fn limit(mut self, limit: u64) -> Self {
        self.limit = Some(limit);
        self
    }

{%- for column in table.columns %}
    pub fn set_{{column.name}}(&mut self, {{column.name}}: {{column.data_type | to_rust_type(is_nullable=true) }}) {
        self.{{column.name}} = {{column.name}};
    }
{%- endfor %}  
    pub fn set_page(mut self, page: Option<u64>) {
        self.page = page;
    }
    pub fn set_limit(mut self, limit: Option<u64>) {
        self.limit = limit;
    }

    pub(crate) fn apply_query_builder(&self) -> QueryBuilder::<MySql>{
        let mut qb = QueryBuilder::<MySql>::new(r#"SELECT {{ table.columns | map(attribute="name") | join(sep=", ")}} FROM {{ table.name }}"#);
        
{%- for column in table.columns %}
        
        if let Some({{column.name}}) = &self.{{column.name}} {
            if !qb.sql().ends_with("WHERE ") {
                qb.push(" WHERE ");
            }
            qb.push("{{column.name}} = ").push_bind({{column.name}});
        }
{%- endfor %}  
        
        let limit = self.limit.unwrap_or(DEFAULT_LIMIT);
        let offset = (self.page.unwrap_or(1) - 1) * limit;

        qb.push(" LIMIT ").push(limit).push(" OFFSET ").push(offset);

        qb
    }
}
